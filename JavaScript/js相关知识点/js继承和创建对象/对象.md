## 对象
一个对象是一组简单数据类型（有时是引用数据类型）的无序列表，被存储为一系列的名-值对(name-value pairs)。这个列表中的每一项被称为 属性（如果是函数则被称为 方法）。

* 在 ECMAScript 中，所有对象并非同等创建的。一般来说，可以创建并使用的对象有三种：本地对象、内置对象和宿主对象。
[对于本地对象的详解](http://blog.csdn.net/z893196569/article/details/48685961)

## 对象的属性
每个对象属性不止保存了自身的名-值对，它同时还包含一些特性
* 数据(数据描述符)属性 :数据属性有4个描述内部属性的特性
[[Configurable]] 表示能否通过delete删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true。  
[[Enumerable]]表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性，如果直接使用字面量定义对象，默认值为true   
[[Writable]]能否修改属性的值，如果直接使用字面量定义对象，默认值为true  
[[Value]]该属性对应的值，默认为undefined    
* 访问器(存取描述符)属性 :访问器属性也有4个描述内部属性的特性  
[[Configurable]] 和数据属性的[[Configurable]]一样，表示能否通过delete删除此属性，能否修改属性的特性，或能否修改把属性修改为访问器属性，如果直接使用字面量定义对象，默认值为true  
[[Enumerable]] 和数据属性的[[Configurable]]一样，表示该属性是否可枚举，即是否通过for-in循环或Object.keys()返回属性，如果直接使用字面量定义对象，默认值为true  
[[Get]] 一个给属性提供 getter 的方法(访问对象属性时调用的函数,返回值就是当前属性的值)，如果没有 getter 则为 undefined。该方法返回值被用作属性值。默认为 undefined  
[[Set]] 一个给属性提供 setter 的方法(给对象属性设置值时调用的函数)，如果没有 setter 则为 undefined。该方法将接受唯一参数，并将该参数的新值分配给该属性。默认为 undefined

### 创建/修改/获取属性的方法
[js中的Object.defineProperty()和defineProperties()  非常好的文章，真的](https://segmentfault.com/a/1190000011294519)

Object的defineProperty和defineProperties这两个方法在js中的重要性十分重要，主要功能就是用来定义或修改这些内部属性,与之相对应的getOwnPropertyDescriptor和getOwnPropertyDescriptors就是获取这行内部属性的描述。

* Object.defineProperty()  
方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。如果不指定configurable, writable, enumerable ，则这些属性默认值为false，如果不指定value, get, set，则这些属性默认值为undefined
` Object.defineProperty(obj, prop, descriptor)`
obj: 需要被操作的目标对象
prop: 目标对象需要定义或修改的属性的名称
descriptor: 将被定义或修改的属性的描述符

* Object.defineProperties() 方法直接在一个对象上定义一个或多个新的属性或修改现有属性，并返回该对象。
`Object.defineProperties(obj, props)`
obj: 将要被添加属性或修改属性的对象
props: 该对象的一个或多个键值对定义了将要为对象添加或修改的属性的具体配置

* Object.getOwnPropertyDescriptor() 该方法返回指定对象上一个自有属性对应的属性描述符。（自有属性指的是直接赋予该对象的属性，不需要从原型链上进行查找的属性）
`Object.getOwnPropertyDescriptor(obj, prop)`
obj: 需要查找的目标对象
prop: 目标对象内属性名称

* Object. getOwnPropertyDescriptors() 所指定对象的所有自身属性的描述符，如果没有任何自身属性，则返回空对象。
` Object.getOwnPropertyDescriptors(obj)`
obj: 需要查找的目标对象

### 各种场景下描述符属性的拓展
#### 在对象中添加一个数据描述符属性
* configrubale 如果设置configrubale属性为false，则不可使用delete操作符(在严格模式下抛出错误)，最开始定义属性描述符时,writabl默认为false,修改内部属性全部报错（在《javaScript高级教程中》说只可以改变writable的值，现在改变writable的值也会抛出错误。），如果writable定义为true, 则可以修改[[writable]]和[[value]]属性值,修改另外两个属性值报错

####在对象中添加存取描述符属性
1. getter和setter可以不同时使用（只指定getter意味着属性是不能写的，尝试写入数据会被忽略，只指定setter的属性是不能读的，会返回undefined）,但在严格模式下只其中一个,会抛出错误
2. 数据描述符与存取描述符不可混用,会抛出错误(在 descriptor 中不能同时设置访问器（get 和 set）和 wriable 或 value，否则会错，就是说想用 get 和 set，就不能用 writable 或 value 中的任何一个。)
3. 只有使用var, let等操作符才是定义变量，而不使用var，直接a=1;,这样a的含义为window的一个属性，并不是我们所说的变量的概念。使用 var定义的任何变量，其configurable属性值都为false,定义对象也是一样
4. 使用字面量定义的对象,该对象内部的属性的数据描述符属性都为true
5. 当writable为false(并且configrubale为true),[[value]]可以通过defineeProperty修改, 但不能直接赋值修改
6. 可以通过get和set实现简单的双向绑定[涉及mvvc我们需要了解一些，主要看里面的链接](https://www.jianshu.com/p/e8df6e3f6e34)

### 创建对象
1. 创建对象最简单的方法就是创建一个Object实例，然后为这个实例添加属性和方法。使用new操作符后跟构造函数，创建一个新对象。

2. 字面量创建
对象字面量是一个表达式，这个表达式的每次运算都将创建并初始化一个新的对象。每次计算对象字面量的时候，也都会计算它每个属性的值。也就是说，如果在一个重复调用的函数中的循环体内使用了对象字面量，它将创建很多新对象，并且每次创建的新对象的属性值也有可能不同。

3. 工厂模式
考虑在ES中无法创建类（ES6前），开发人员发明了一种函数，用函数来封装以特定接口创建对象的细节。工厂模式就是将创建对象的语句放在一个函数里，通过传入参数来创建特定对象，最后返回创建的对象。**工厂模式虽然可以创建多个相似的对象，但却不能解决对象标识的问题，即怎样知道一个对象的类型。(创建过程被封装，无法知道创建了什么类型)**

4. 构造函数模式
像Object和Array这样的原生构造函数，在运行时会自动出现在执行环境。此外，也可以创建自定义的构造函数，从而定义自定义对象类型的属性和方法。构造函数的函数名首字母是大写的，而普通函数首字母则是小写（如果不用new来调用构造含函数那他和不同函数没有什么区别）

与工厂模式相比
* 没有显示地创建对象
* 直接将属性和方法赋给this对象
* 没有return语句
* 可以用instanceof检测对象类型。
**要创建实例，必须要使用new操作符，创建的实例对象将有一个constructor（构造器）属性，指向构造函数。**

调用构造函数创建对象经过了以下几个过程：
* 创建一个新对象
* 将构造函数的作用域赋给新对象（因此this就指向了这个新对象）
* 执行构造函数中的代码
* 返回新对象（不需要显式返回）

缺点：每个方法都要在每个实例上创建一遍。在ECMAScript中，函数即对象，因此每定义一个函数，也就是实例化了一个对象。也就是说通过构造函数实例化的多个对象的方法，是多个不同的方法，但它们内部的代码以及实现的功能是相同的，这就造成了一定的资源浪费。可以吧方法定义在构造函数外部，但是这样要定义很多个全局函数，这样自定义的引用类型就没有封装性可言了。

4. 原型模式
js中，每个函数都有一个prototype属性，它是一个指针，指向一个对象，叫做原型对象，原型对象包含了可以由特定类型的所有实例对象共享的属性和方法。此外，这个对象有一个与生自来的属性constructor，指向创建对象的构造方法。
**使用原型模式可以让所有的实例共享原型对象中的属性和方法，也就是说，不必再构造函数中定义对象实例的信息，通过实例对象属性覆盖原型对象上的同名属性**
* 缺点：原型中的所有属性都是被所有实例所共享的，这种共享对于函数来说非常合适，对于包含基本值的属性也说的过去（实例属性会覆盖原型同名属性），但对于那些包含引用类型的属性，当被一个实例修改后，会改变所有实例中的该属性。

5. 组合使用构造函数和原型模式
**构造函数模式用于定义实例属性，原型模式则用于定义方法和共享的属性**。这种混合模式不仅支持向构造函数传入参数，让每个实例都有自己的实例属性的副本，同时又共享着对方法的引用，最大限度地节约了内存。

6. 动态原型模型
将所有信息封装到构造函数中，通过构造函数初始化原型（仅仅在必要的情况下,原型中不存在某个方法时，可以用if语句检查），同时又保持着构造函数和原型的优点。**不要使用对象字面量重写原型，如果在已经创建实例的情况下重写原型，那么就会切断现有实例与新原型之间联系**

7. 寄生构造函数模式
除了使用new操作符并把使用的包装函数叫做构造函数之外，这个模式和与工厂模式其实一模一样。返回的对象与构造函数和构造函数的原型没有关系，不能依赖instanceof来确定对象类型。

8. 稳妥构造函数模式
稳妥对象：指没有公共属性，其方法也不引用this对象。适合用在一些安全的环境（禁止使用this和new）或者防止数据被其他应用程序改动时使用。和寄生构造函数模式类似，但新创建的**对象不引用this，而且不使用new操作符调用构造函数。只有他的方法能调用内部数据，不可能有其他方法可以访问传入到构造函数中的原始数据。**

