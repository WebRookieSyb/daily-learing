##### 执行上下文环境
javascript是一个单线程语言，这意味着在浏览器中同时只能做一件事情。当javascript解释器初始执行代码（代码解析阶段），它首先默认进入全局上下文。每次调用一个函数将会创建一个新的执行上下文。 
定义：执行函数的时候，会产生一个上下文的对象，里面保存变量，函数声明和this。  
作用：有一个变量对象，用来保存本次运行时所需要的数据。
#####具体过程


1. 建立variableObject对象（变量对象）:
2. 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值
3. 检查当前上下文中的函数声明：
每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用

如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。

4. 初始化作用域链，并保存在变量对象中
5. 确定上下文中this的指向对象     


在产生执行上下文(执行上下文环境)时，浏览器会做以下三个准备工作：
1. 提取var 声明的变量，并赋值为 undefined
2. 给this赋值，指向window或当前对象。
3. 提取声明式函数（函数表达式-与var声明对象相同）。 函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域（函数整个被保存）。函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。  
javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。
* 全局上下文环境  
全局级别的代码，如多个script标签，一旦执行就会进入全局执行上下文环境   
1.提取普通变量，如 var a  ，并赋值 a = undefined  
2.提取声明式函数，function fn(){}  
3.给 this 赋值，this指向window  
* 局部上下文环境  
在函数调用的时候产生，每一次调用就会产生，调用完成后销毁(除闭包)。（js中for和if、else无法创建作用域,只有函数创建作用域）
作用域在函数被声明的时候就创建了，而上下文环境在执行调用的时候产生 
1.给arguments 赋值 （赋具体值）    
2.提取声明式函数，function fn(){} 
3.给参数赋值 （赋具体值） 
4.提取普通变量，如 var a  ，并赋值 a = undefined  
5.给 this 赋值，this指向当前对象    
6.自由变量的取值作用域，查找并赋值  
自由变量：在当前作用域中未声明的变量，会去其上一级查找，直到window  
arguments:是一个实参副本，与实参保持一致。  

#####局部变量作用域提升
变量名提升:编译阶段，编译器会将函数里所有的声明都提前到函数体内的上部，而真正赋值的操作留在原来的位置
在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，由于执行上下文环境的建立，函数具体执行时一进入函数体，就可以访问到其中声明的变量以及函数。
##### this
在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。
* 构造函数 
所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。  
如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。
如果直接调用，这种情况下this是window。
* 函数作为对象的一个属性 
如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。
如果fn函数不作为obj的一个属性被调用，依旧指向window
* 当一个函数被call和apply调用时，this的值就取传入的对象的值
* 在全局环境下，this永远是window

####执行上下文栈  
每次新创建的一个执行上下文会被添加到作用域链的顶部，有时也称为执行或调用栈。浏览器总是运行位于作用域链顶部的当前执行上下文。一旦完成，当前执行上下文将从栈顶被移除并且将控制权归还给之前的执行上下文。出栈后，会销毁本次调用的局部上下文环境。
处于活动状态的执行上下文环境只有一个，其实这是一个压栈出栈的过程——执行上下文栈。
* 单线程
* 同步执行
* 唯一的一个全局上下文
* 函数的执行上下文的个数没有限制
* 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

####作用域 
javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句和for   
javascript除了全局作用域之外，只有函数可以创建的作用域。   
作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了

####自由变量
在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量

####静态作用域
作用域是静态的  在函数创建时就确定了
要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，这只是跨一步作用域去寻找。如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。

##### 作用域链

在javascript中的每个函数都是对象，是Funtion对象的一个实例，而Funtion中有一系列仅供javascript引擎存取的内部属性，其中一个便是**[[scope]]，它包含了一个函数被创建的作用域中对象的集合，这个集合就是函数的作用域链。当一个函数创建后，它的作用域链会被创建此函数的作用域中可访问的数据对象填充。**
函数创建时，它的作用域链中会填入一个单独的可变对象，即全局对象，该全局对象包含了所有全局变量

执行此函数会创建一个称为执行上下文的内部对象，一个执行上下文定义了一个函数执行时的环境，函数每次执行时对应的执行上下文都是独一无二的，所以多次调用统一个函数会导致创建多个执行上下文，当函数执行完毕，执行上下文被销毁。每个执行下文都有自己的作用域链，用于标识符解析，当执行上下文被创建时，**它的作用域链初始化为当前运行函数的[[Scope]]所包含的对象。这些值按照它们出现在函数中的顺序被复制到运行期上下文的作用域链中。**它们共同组成了一个新的对象，叫“活动对象(activation object)”，活动对象作为函数运行期的可变对象，该对象包含了函数的所有局部变量、命名参数、参数集合以及this，即它通过函数的arguments属性初始化，arguments属性的值对是Arguments象：

【Arguments对象是活动对象的一个属性，它包括如下属性：

callee — 指向当前函数的引用
length — 真正传递的参数个数
properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes内部元素的个数等于arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。
　　这个共享其实不是真正的共享一个内存地址，而是2个不同的内存地址，使用JavaScript引擎来保证2个值是随时一样的，当然这也有一个前提，那就是这个索引值要小于你传入的参数个数，也就是说如果你只传入2个参数，而还继续使用arguments[2]赋值的话，就会不一致

1、形参个数： arguments.callee.length 或者 函数名.length ，arguments.callee就是取得函数的名字。

2、实参个数： arguments.length

* 活动对象中的this ：this对象 是在运行时基于函数的执行环境绑定的。(每个函数被调用时,其活动对象都会自动取得两个特殊的变量,this和 arguments.内部函数在搜索这两个变量时,只会搜索到其活动对象为止,因此永远不可能直接访问外部函数中的这两个变量,不过可以把外部作用域中的this对象保存在一个闭包能够访问到的变量(that)里,就可以让闭包访问该对象(object)了,访问arguments对象的作法类似)

因为闭包的[[scope]]属性包含了与运行期上下文作用域链相同的对象的引用，因此，当外层函数执行完毕时，由于引用仍然存在闭包的[[scope]]属性中，故活动对象无法被销毁，会使内存消耗大，即造成内存泄漏。

函数的活动对象会随同运行期上下文一同销毁，但引入闭包时，由于仍然存在于闭包的[[scope]]属性中，因此活动对象无法被销毁，所以脚本中的闭包与非闭包相比，需要更多的内存

在函数执行的过程中，每遇到一个变量，都会经历一次标识符解析过程，该过程搜索运行期上下文的作用域，查找同名的标识符，这个过程会影响性能。

当闭包被执行的时候，一个执行上下文又被创建，它的作用域链与属性[[scope]]中引用的两个相同的作用域链对象同时被初始化，然后一个活动对象被闭包自身所创建。

在函数执行的过程中，每遇到一个变量，都会经历一次标识符解析过程，该过程搜索运行期上下文的作用域，查找同名的标识符，这个过程会影响性能。

//作用域在函数被声明的时候就创建了，而上下文环境在执行调用的时候产生
        var a = 10;
        function fn() {
            console.log(a);//这里的a是自由变量
        }
        function f2(f) {
            var a = 5;
            f(); 
        }
        f2(fn);//输出10，而不是5
[http://blog.csdn.net/wangxiaohu__/article/details/7260668 写的挺好的一个博客](http://blog.csdn.net/wangxiaohu__/article/details/7260668)

[https://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html 汤姆大叔的博文，看的我都要流下泪，讲的太仔细,必看](https://www.cnblogs.com/TomXu/archive/2012/01/18/2312463.html)
##### 闭包
由于链式作用域，函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的局部变量。
* 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！  

闭包是指有权访问另一个函数作用域的变量的函数  

```function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}

　　}
```
在f1中声明函数f2调用了f1的参数，形成了闭包，但他并不是我们所说通常意义上的闭包。当该f2作为返回值被f1返回并被赋值给一个全局变量时才形成真正所谓的闭包
```　function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n); 
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999
```
f2()被赋值给一个全局变量，f2一直被保存在全局上下文执行环境中，虽然f1()函数的执行环境销毁了，但其变量对象一直存在于内存中，就是为了能够使得调用f2()函数时，可以通过作用域链访问到父函数f1()，并得到其变量对象中储存的变量值。直到页面关闭，f1()函数的变量对象才会和全局的变量对象一起被销毁，从而释放内存空间。

* 闭包会引用包含函数的整个活动对象
#### 作用
1. 可以读取函数内部的变量
2. 让这些变量的值始终保持在内存中
3. 模仿块级作用域，通常可以在用一个自执行匿名函数将代码包裹，可以限制向全局变量中添加过多变量和函数，从而减少命名冲突。
4. 可以通过闭包建立私有变量和私有函数，再构建可以访问私有变量和函数的特权方法（涉及构造函数和设计模式）

####缺点
会造成内存泄漏：由于低版本ie的垃圾回收机制在dom和bom上采用引用计数的方法，当闭包的作用域链中保存着一个html元素时，改元素会无法销毁。因此要去除循环引用而且要在使用结束后把必要变量值设为null。