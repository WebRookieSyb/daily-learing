##### 执行上下文环境
javascript是一个单线程语言，这意味着在浏览器中同时只能做一件事情。当javascript解释器初始执行代码（代码解析阶段），它首先默认进入全局上下文。每次调用一个函数将会创建一个新的执行上下文。 
定义：执行函数的时候，会产生一个上下文的对象，里面保存变量，函数声明和this。  
作用：有一个变量对象，用来保存本次运行时所需要的数据。
#####具体过程


1. 建立variableObject对象（变量对象）:
2. 建立arguments对象，检查当前上下文中的参数，建立该对象下的属性以及属性值
3. 检查当前上下文中的函数声明：
每找到一个函数声明，就在variableObject下面用函数名建立一个属性，属性值就是指向该函数在内存中的地址的一个引用

如果上述函数名已经存在于variableObject下，那么对应的属性值会被新的引用所覆盖。

4. 初始化作用域链，并保存在变量对象中
5. 确定上下文中this的指向对象     


在产生执行上下文(执行上下文环境)时，浏览器会做以下三个准备工作：
1. 提取var 声明的变量，并赋值为 undefined
2. 给this赋值，指向window或当前对象。
3. 提取声明式函数（函数表达式-与var声明对象相同）。 函数在定义的时候（不是调用的时候），就已经确定了函数体内部自由变量的作用域（函数整个被保存）。函数每被调用一次，都会产生一个新的执行上下文环境。因为不同的调用可能就会有不同的参数。  
javascript在执行一个代码段之前，都会进行这些“准备工作”来生成执行上下文。这个“代码段”其实分三种情况——全局代码，函数体，eval代码。
* 全局上下文环境  
全局级别的代码，如多个script标签，一旦执行就会进入全局执行上下文环境   
1.提取普通变量，如 var a  ，并赋值 a = undefined  
2.提取声明式函数，function fn(){}  
3.给 this 赋值，this指向window  
* 局部上下文环境  
在函数调用的时候产生，每一次调用就会产生，调用完成后销毁(除闭包)。（js中for和if、else无法创建作用域,只有函数创建作用域）
作用域在函数被声明的时候就创建了，而上下文环境在执行调用的时候产生 
1.给arguments 赋值 （赋具体值）    
2.提取声明式函数，function fn(){} 
3.给参数赋值 （赋具体值） 
4.提取普通变量，如 var a  ，并赋值 a = undefined  
5.给 this 赋值，this指向当前对象    
6.自由变量的取值作用域，查找并赋值  
自由变量：在当前作用域中未声明的变量，会去其上一级查找，直到window  
arguments:是一个实参副本，与实参保持一致。  

#####局部变量作用域提升
变量名提升:编译阶段，编译器会将函数里所有的声明都提前到函数体内的上部，而真正赋值的操作留在原来的位置
在函数中声明的变量以及函数，其作用域提升到函数顶部，换句话说，由于执行上下文环境的建立，函数具体执行时一进入函数体，就可以访问到其中声明的变量以及函数。
##### this
在函数中this到底取何值，是在函数真正被调用执行的时候确定的，函数定义的时候确定不了。因为this的取值是执行上下文环境的一部分，每次调用函数，都会产生一个新的执行上下文环境。
* 构造函数 
所谓构造函数就是用来new对象的函数。其实严格来说，所有的函数都可以new一个对象，但是有些函数的定义是为了new一个对象，而有些函数则不是。另外注意，构造函数的函数名第一个字母大写（规则约定）。例如：Object、Array、Function等。  
如果函数作为构造函数用，那么其中的this就代表它即将new出来的对象。
如果直接调用，这种情况下this是window。
* 函数作为对象的一个属性 
如果函数作为对象的一个属性时，并且作为对象的一个属性被调用时，函数中的this指向该对象。
如果fn函数不作为obj的一个属性被调用，依旧指向window
* 当一个函数被call和apply调用时，this的值就取传入的对象的值
* 在全局环境下，this永远是window

####执行上下文栈  
每次新创建的一个执行上下文会被添加到作用域链的顶部，有时也称为执行或调用栈。浏览器总是运行位于作用域链顶部的当前执行上下文。一旦完成，当前执行上下文将从栈顶被移除并且将控制权归还给之前的执行上下文。出栈后，会销毁本次调用的局部上下文环境。
处于活动状态的执行上下文环境只有一个，其实这是一个压栈出栈的过程——执行上下文栈。
* 单线程
* 同步执行
* 唯一的一个全局上下文
* 函数的执行上下文的个数没有限制
* 每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

####作用域 
javascript没有块级作用域”。所谓“块”，就是大括号“｛｝”中间的语句。例如if语句和for   
javascript除了全局作用域之外，只有函数可以创建的作用域。   
作用域只是一个“地盘”，一个抽象的概念，其中没有变量。要通过作用域对应的执行上下文环境来获取变量的值。同一个作用域下，不同的调用会产生不同的执行上下文环境，继而产生不同的变量的值。所以，作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了

####自由变量
在A作用域中使用的变量x，却没有在A作用域中声明（即在其他作用域中声明的），对于A作用域来说，x就是一个自由变量

####静态作用域
作用域是静态的  在函数创建时就确定了
要到创建这个函数的那个作用域中取值——是“创建”，而不是“调用”，这只是跨一步作用域去寻找。如果跨了一步，还没找到呢？——接着跨！——一直跨到全局作用域为止。要是在全局作用域中都没有找到，那就是真的没有了。这个一步一步“跨”的路线，我们称之为——作用域链。

##### 作用域链
作用域链在执行上下文环境的时候已经被确定
不同执行上下文之间的变量命名冲突通过攀爬作用域链解决，从局部直到全局。这意味着具有相同名称的局部变量在作用域链中有更高的优先级。 
简单的说，每次你试图访问函数执行上下文中的变量时，查找进程总是从自己的变量对象开始。如果在自己的变量对象中没发现要查找的变量，继续搜索作用域链。它将攀爬作用域链检查每一个执行上下文的变量对象，寻找和变量名称匹配的值。

##### 闭包
由于链式作用域，函数内部可以直接读取全局变量，在函数外部自然无法读取函数内的局部变量。
* 函数内部声明变量的时候，一定要使用var命令。如果不用的话，你实际上声明了一个全局变量！  

闭包是指有权访问另一个函数作用域的变量的函数  

```function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n); // 999
　　　　}

　　}
```
在f1中声明函数f2调用了f1的参数，形成了闭包，但他并不是我们所说通常意义上的闭包。当该f2作为返回值被f1返回并被赋值给一个全局变量时才形成真正所谓的闭包
```　function f1(){

　　　　var n=999;

　　　　function f2(){
　　　　　　alert(n); 
　　　　}

　　　　return f2;

　　}

　　var result=f1();

　　result(); // 999
```
f2()被赋值给一个全局变量，f2一直被保存在全局上下文执行环境中，虽然f1()函数的执行环境销毁了，但其变量对象一直存在于内存中，就是为了能够使得调用f2()函数时，可以通过作用域链访问到父函数f1()，并得到其变量对象中储存的变量值。直到页面关闭，f1()函数的变量对象才会和全局的变量对象一起被销毁，从而释放内存空间。

* 闭包会引用包含函数的整个活动对象
#### 作用
1. 可以读取函数内部的变量
2. 让这些变量的值始终保持在内存中
3. 模仿块级作用域，通常可以在用一个自执行匿名函数将代码包裹，可以限制向全局变量中添加过多变量和函数，从而减少命名冲突。
4. 可以通过闭包建立私有变量和私有函数，再构建可以访问私有变量和函数的特权方法（涉及构造函数和设计模式）

####缺点
会造成内存泄漏：由于低版本ie的垃圾回收机制在dom和bom上采用引用计数的方法，当闭包的作用域链中保存着一个html元素时，改元素会无法销毁。因此要去除循环引用而且要在使用结束后把必要变量值设为null。