# 浏览器的主要结构
1. 用户接口 – 包括地址栏，前进后退，书签菜单等窗口上除了网页显示区域以外的部分。
2. 浏览器引擎 – 查询与操作渲染引擎的接口。
3. 渲染引擎 – 负责显示请求的内容。比如请求到HTML, 它会负责解析HTML 与 CSS 并将结果显示到窗口中。
4. 网络 – 用于网络请求, 如HTTP请求。它包括平台无关的接口和各平台独立的实现。
5. UI后端 – 绘制基础元件，如组合框与窗口。它提供平台无关的接口，内部使用操作系统的相应实现。
6. JavaScript解释器。用于解析执行JavaScript代码。
7. 数据存储。这是一个持久层。浏览器需要把所有数据存到硬盘上，如cookies。新的HTML规范 (HTML5) 规定了一个完整（虽然轻量级）的浏览器中的数据库：’web database’。
(需要注意的是，与其它浏览器不同，chrome使用多个渲染引擎实例，每个Tab一个，每个Tab都是一个独立进程。)

## 渲染引擎

* 渲染引擎：把请求的内容显示到浏览器屏幕上。默认情况下渲染引擎可以显示HTML，XML文档以及图片。 通过插件（浏览器扩展）它可以显示其它类型文档。比如使用PDF viewer插件显示PDF文件。

我们提到的Firefox, Safari两种浏览器构建于两种渲染引擎之上：Firefox使用Gecko —— Mozilla自家的渲染引擎；Safari 和 Chrome 都使用 Webkit。

**渲染引擎开始于从网络层获取请求内容，一般是不超过8Ｋ的数据块。接下来就是渲染引擎的基本工作流程：解析HTML构建DOM树，渲染树构建，渲染树布局，绘制渲染树**
### 具体过程
1. 渲染引擎会解析ＨＴＭＬ文档并把标签转换成内容树中的ＤＯＭ节点。它会解析style元素和外部文件中的样式数据。样式数据和ＨＴＭＬ中的显示控制将共同用来创建另一棵树——渲染树。

2. 渲染树包含带有颜色，尺寸等显示属性的矩形。这些矩形的顺序与显示顺序一致。

3. 渲染树构建完成后就是”布局“处理，也就是确定每个节点在屏幕上的确切显示位置。 下一个步骤是 绘制 —— 遍历渲染树并用ＵＩ后端层将每一个节点绘制出来。

4. 一定要理解这是一个缓慢的过程，为了更好的用户体验，渲染引擎会尝试尽快的把内容显示出来。它不会等到所有ＨＴＭＬ都被解析完才创建并布局渲染树。它会 在处理后续内容的同时把处理过的局部内容先展示出来。

### HTML解析
语法可以用类似ＢＮＦ的格式规范地定义。不幸的是所有常规解析器的讨论都不适用于ＨＴＭＬ（我提及它们并不是为了娱乐，它们可以用于解析CSS和JavaScript）。HTML无法用解析器所需的上下文无关的语法来定义。过去HTML格式规范由DTD (Document Type Definition)来定义，但它不是一个上下文无关语法。

HTML与XML相当接近。XML有许多可用的解析器。HTML还有一个XML变种叫XHTML，那么它们主要区别在哪里呢？区别在于HTML应用更加”宽容”，它容许你漏掉一些开始或结束标签等。它整个是一个“软”句法，不像XML那样严格死板。 总的来说这一看似细微的差别造成了两个不同的世界。一方面这使得HTML很流行，因为它包容你的错误，使网页作者的生活变得轻松。另一方面，它使编写语法格式变得困难。所以综合来说，ＨＴＭＬ解析并不简单，现成的上下文相关解析器搞不定，ＸＭＬ解析器也不行。

**DTD 文档类型定义(Document Type Definition)是一套为了进行程序间的数据交换而建立的关于标记符的语法规则**
文档类型定义（DTD）可定义合法的XML文档构建模块。它使用一系列合法的元素来定义文档的结构。它包含对所有允许的元素的定义，包括它们的属性和层级关系
DTD 可被成行地声明于 XML 文档中，也可作为一个外部引用。（DOCTYPE 声明）

**BNF BNF范式是一种用递归的思想来表述计算机语言符号集的定义规范**
在双引号中的字("word")代表着这些字符本身。
在双引号外的字（有可能有下划线）代表着语法部分
尖括号( < > )内包含的为必选项。
方括号( [ ] )内包含的为可选项。
大括号( { } )内包含的为可重复0至无数次的项。
竖线( | )表示在其左右两边任选一项，相当于"OR"的意思。
::= 是“被定义为”的意思。

#### HTML无法使用自上而下或自下而上的解析器来解析。
1. 语言的宽容特点
2. 浏览器需要对无效HTML提供容错性的事实。
3. 解析过程的反复。通常解析过程中源码不会变化。但在HTML中，script标签包含”document.write”时可以添加内容，即解析过程实际上还会改变源码。

* 浏览器创建了自己的解析器来解析HTML文档。
**HTML5规范里对解析算法有具体的说明，解析由两部分组成：分词与构建树。**

分词属于词法分析部分，它把输入解析成符号序列。在HTML中符号就是开始标签，结束标签，属性名称和属生值。
分词器识别这些符号并将其送入树构建者，然后继续分析处理下一个符号，直到输入结束。

解析器输出的DOM树是由ＤＯＭ元素和属性节点组成的。**DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。**DOM的全称为：Document Object Model。它是ＨＴＭＬ文档的对象化描述，也是ＨＴＭＬ元素与外界（如Javascript）的接口。ＤＯＭ与标签几乎有着一一对应的关系（节点包括元素，元素时有内容和属性的节点）

**浏览器会修正错误HTML页面语法错误并继续。**

解析器分析输入符号生成文档，并构建文档树。如果文档格式良好，解析工作会很简单。
不幸的是，我们要处理很多格式不良的HTML文档，解析器需要宽容这些错误。
我们至少需要照顾下列错误：
1. 元素必需被插入在正确的位置。未关闭的标签应该一一关闭，直到可以添加新元素。
2. 不允许直接添加元素。用户可能会漏掉一些标签，比如：HTML HEAD BODY TBODY TR TD LI（我遗漏了什么？）。
3. 在inline元素里添加block元素时，应关闭所有inline元素，再添加block元素。
4. 如果以上不起作用，关闭所有元素，直到可以添加，或者忽略此标签。

例子：
1. 一个表格包含在另外一个表格的内容中，但不是在外部表格的单元格里，Webkit会改变层级关系，把它们处理成两个相临的表格，Webkit用一个堆栈保存当前元素，它会把里面的表格弹出到外部表格堆栈，使它们成为兄弟表格。
2. 我们只标签嵌套允许同一标签连续出现20次，超过的话，所有此标签都会被忽略。
3. 错误的html或body结束标签位置永远不关闭tag，因为有些愚蠢的网页在文档真正结束之前就关闭了它。让我们用end()来关闭标签。

### 渲染树
CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。

Render Tree：DOM 和 CSSOM 合并后生成 Render Tree(渲染树)Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点。

注意：display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。Header也不会放在渲染树中。还有没有任何属性的元素。

### 浏览器渲染过程
1. Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。

注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script 节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区。

2. Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM

3. Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。

4. Layout（布局）：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。

5. Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。


以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。

* Reflow回流（重排）：浏览器要花时间去渲染，当它发现了某个部分发生了变化影响了布局，那就需要倒回去重新渲染。

（1）页面初始化的时候； 
（2）操作DOM时（动态获取，生成，删除元素等）
（3）某些元素的尺寸变了； 
（4）如果某些CSS 的属性发生变化了。
（5）窗口大小改变时

* Repaint（重绘）：如果只是改变了某个元素的背景颜色，文字颜色等，不影响元素周围或内部布局的属性，将只会引起浏览器的repaint，重画某一部分。Reflow要比Repaint更花费时间，也就更影响性能。所以在写代码的时候，要尽量避免过多的Reflow。

* 减少重绘和回流

（1）不要一条一条地修改 DOM 的样式。与其这样，还不如预先定义好 css 的 class，然后修改 DOM 的 className。 
　（2）不要把 DOM 结点的属性值放在一个循环里当成循环里的变量。 
　（3）为动画的 HTML 元件使用 fixed 或 absoult 的 position，那么修改他们的 CSS 是不会 reflow 的。 
　（4）千万不要使用 table 布局。因为可能很小的一个小改动会造成整个 table 的重新布局。

首屏时间和DomContentLoad事件没有必然的先后关系

所有CSS尽早加载是减少首屏时间的最关键

js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。

普通script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。

### css注意点
由于CSS选择符是从右到左进行匹配的。
1. dom深度尽量浅。
2. 减少inline javascript、css的数量。
3. 使用现代合法的css属性。
4. 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。
5. 避免后代选择符，尽量使用子选择符。原因：子元素匹配符的概率要大于后代元素匹配符。后代选择符;#tp p{} 子选择符：#tp>p{}
6. 避免使用通配符，举一个例子，.mod .hd *{font-size:14px;} 根据匹配顺序,将首先匹配通配符,也就是说先匹配出通配符,然后匹配.hd（就是要对dom树上的所有节点进行遍历他的父级元素）,然后匹配.mod,这样的性能耗费可想而知.
### js的加载
 通常来说，浏览器对于Javascript的运行有两大特性：**1）载入后马上执行，2）执行时会阻塞页面后续的内容（包括页面的渲染、其它资源的下载）。于是，如果有多个js文件被引入，那么对于浏览器来说，这些js文件被被串行地载入，并依次执行。**

 基本上来说，head里的 `<script>`标签会阻塞后续资源的载入以及整个页面的生成。所以，你知道为什么有很多网站把javascript放在网页的最后面了，要么就是动用了window.onload或是docmuemt ready之类的事件。

1. 不能并行下载和解析（阻塞下载），因此需要等待js整个文件加载完之后才能继续DOM的加载，倘若js脚本文件过大，则可能导致浏览器页面显示滞后，出现“假死”状态，这种效应称之为“阻塞效应”；会导致出现非常不好的用户体验。 

2. 当引用了JS的时候，浏览器发送1个js request就会一直等待该request的返回。因为浏览器需要1个稳定的DOM树结构，而JS中很有可能有 
代码直接改变了DOM树结构，比如使用 document.write 或 appendChild,甚至是直接使用的location.href进行跳转，浏览器为了防止出现JS修 
改DOM树，需要重新构建DOM树的情况，所以 就会阻塞其他的下载和呈现. 

如果在解析html的时候遇到js会阻塞页面渲染，所以一般我们会将所有的script标签放到页面底部，也就是body闭合标签之前，这能确保在脚本执行前页面已经完成了DOM树渲染。尽可能地合并脚本。页面中的script标签越少，加载也就越快，响应也越迅速。无论是外链脚本还是内嵌脚本都是如此。

* 采用无阻塞下载 JavaScript 脚本的方法： 
（1）使用script标签的 defer、async 属性、； 
（2）使用动态创建的script元素来下载并执行代码等异步加载等方法；

defer、async都是异步下载，但是执行时刻不一致；
* 相同点：

加载文件时不阻塞页面渲染；
使用这两个属性的脚本中不能调用document.write方法；
允许不定义属性值，仅仅使用属性名；
* 不同点：

html的版本html4.0中定义了defer，html5.0中定义了async；这将造成由于浏览器版本的不同而对其支持的程度不同；
每一个async属性的脚本都在它下载结束之后立刻执行，同时会在window的load事件之前执行，所以就有可能出现脚本执行顺序被打乱 的情况；
每一个defer属性的脚本都是在页面解析完毕之后，按照原本的顺序执行，同时会在document的DOMContentLoaded之前执行；

### 如何加快HTML页面加载速度  
 页面减肥： 

a. 页面的肥瘦是影响加载速度最重要的因素。 

b. 删除不必要的空格、注释。 

c. 将inline的script和css移到外部文件。 

d. 可以使用HTML Tidy来给HTML减肥，还可以使用一些压缩工具来给JavaScript减肥。 

2. 减少文件数量： 

a. 减少页面上引用的文件数量可以减少HTTP连接数。 

b. 许多JavaScript、CSS文件可以合并最好合并，人家财帮子都把自己的JavaScript. functions和Prototype.js合并到一个base.js文件里去了。 

3. 减少域名查询： 

a. DNS查询和解析域名也是消耗时间的，所以要减少对外部JavaScript、CSS、图片等资源的引用，不同域名的使用越少越好。 

4. 缓存重用数据： 

a. 对重复使用的数据进行缓存。 

5. 优化页面元素加载顺序： 

a. 首先加载页面最初显示的内容和与之相关的JavaScript和CSS，然后加载HTML相关的东西，像什么不是最初显示相关的图片、flash、视频等很肥的资源就最后加载。 

6. 减少inline JavaScript的数量： 

a. 浏览器parser会假设inline JavaScript会改变页面结构，所以使用inline JavaScript开销较大。 

b. 不要使用document.write()这种输出内容的方法，使用现代W3C DOM方法来为现代浏览器处理页面内容。 

7. 使用现代CSS和合法的标签： 

a. 使用现代CSS来减少标签和图像，例如使用现代CSS+文字完全可以替代一些只有文字的图片。 

b. 使用合法的标签避免浏览器解析HTML时做“error correction”等操作，还可以被HTML Tidy来给HTML减肥。 

8. Chunk your content： 

a. 不要使用嵌套table，而使用非嵌套table或者div。将基于大块嵌套的table的layout分解成多个小table，这样就不需要等到整个页面（或大table）内容全部加载完才显示。 

9. 指定图像和table的大小： 

a. 如果浏览器可以立即决定图像或table的大小，那么它就可以马上显示页面而不要重新做一些布局安排的工作。 

b. 这不仅加快了页面的显示，也预防了页面完成加载后布局的一些不当的改变。 

c. image使用height和width。 

[博客](https://www.cnblogs.com/CandyManPing/p/6635008.html)    
[【译】提高网站访问速度的34条军规](http://www.cnblogs.com/smjack/archive/2009/02/24/1396895.html)   
[浏览器渲染过程](http://www.cnblogs.com/wyaocn/p/5824721.html)
