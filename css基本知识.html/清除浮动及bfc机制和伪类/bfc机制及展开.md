## BFC机制及展开
### 文档流和文本流  
文档流（标准流 Normal Flow）是指html文档加载解析时从上到下，从左向右，是相对于盒子模型来说的。  
文本流是指html文本的显示，是相对于文字段落来说的。    
元素浮动后，会让他跳出文档流，后面的元素在布局时会直接占在它的下方布局，但和面元素中的文字却会认同浮动元素所占据的区域，围绕它布局，没有脱出文本流。但元素绝对定位后（absolute，fixed），不仅元素盒子会脱出文档流也会脱出文本流，元素后面的文字不会再认同它所占的位置，不会再环绕。
### 居中 
margin：0 auto; 可以设置块级水平居中 是因为块级元素的宽度默认是撑满父级元素的，如果给宽度设置一个固定值，而左右margin设置为auto，则可以平分剩余空间，而垂直方向不可以居中是因为块级元素的高度默认是内容高度，与父级元素的高度并没有直接的关系，而上下margin设置为auto，则被重置为0。  

### BFC机制
#### 视觉格式化模型  
视觉格式化模型(visual formatting model)是用来处理文档并将它显示在视觉媒体上的机制，它也是CSS中的一个概念。 
视觉格式化模型定义了盒（Box）的生成，盒主要包括了块盒、行内盒、匿名盒（没有名字不能被选择器选中的盒）
#### 三种定位方案
在定位的时候，浏览器就会根据元素的盒类型和上下文对这些元素进行定位，可以说盒就是定位的基本单位。定位时，有三种定位方案，分别是常规流，浮动以及绝对定位
### BFC（块级格式化上下文）
#### 定义
它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。
FC是formatting context的首字母缩写，直译过来是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用
#### 创建BFC的方法：
1. 根元素HTML；
2. 浮动 (元素的float不为none)；
3. 绝对定位元素 (元素的position为absolute或fixed)；
4. 行内块inline-blocks(元素的 display: inline-block)；
5. 表格单元格(元素的display: table-cell，HTML表格单元格默认属性)；
6. overflow的值不为visible的元素；
#### BFC规则
1. 如果给一个元素创建了一个BFC，就相当于创建了一个新的容器，容器内和容器外中的元素不会相互影响。BFC包含创建该上下文元素的所有子元素，但不包括创建了新BFC的子元素的内部元素。也就是说一个元素不能同时存在于两个BFC中，让处于BFC内部的元素与外部的元素相互隔离，使内外元素的定位不会相互影响。

2. 盒子的布局开始是从包含容器的顶部开始的。

3. Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠 
注意：发生重叠后，外边距的高度等于两个发生重叠的外边距的高度中的较大者
[外边距折叠](https://www.w3cplus.com/css/understanding-bfc-and-margin-collapse.html)

4. 每个元素的margin box的左边， 与包含块border box的左边相接触（对于从左往右的格式化，否则相反,这也就解释了为什么块级元素都是单独成一行的，如果不单独成行，第二个盒子的左边界怎么紧靠包含容器的左边界），即使存在浮动也是如此（给子元素加浮动，如果没有清除浮动的话，父元素不会将下面两个子元素包裹，但还是在父元素的范围之内，左浮是子元素的左边接触父元素的borderbox的左边，右浮亦然）；
5. 计算BFC的高度时，考虑BFC所包含的所有元素，连浮动元素也参与计算；
6. 浮动盒区域不叠加到BFC上（BFC元素不会与浮动元素重叠）；
#### BFC的作用
1. 自适应两栏布局 （BFC元素不会与浮动元素重叠）给一边浮动，一边创建BFC(overflow:hidden;)
2. 可以阻止元素被浮动元素覆盖
3. 可以包含浮动元素——清除内部浮动
4. 分属于不同的BFC时可以阻止margin重叠
当两个相邻块级子元素分属于不同的BFC时可以阻止margin重叠,给其中一个div外面包一个div，然后通过触发外面这个div的BFC，就可以阻止这两个div的margin重叠
#### 兼容ie
IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用触发条件中的 CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 zoom: 1 来触发 IE 浏览器的 Layout。
### IFC（行级格式化上下文）  
不是所有块级盒内部都可以产生BFC，比如说要是这盒里面连块级盒都没有，都是行内盒那就产生IFC，不过，只要它的子节点里面有一个块级盒，它就产生BFC，那些行内元素，会自动套一个匿名的块级行盒。   
### 清除浮动
* 浮动 之后会怎么样？ 
1、浮动定位元素会被排除在文档流之外-脱离文档流(不占据页面空间),其余的元素要上前补位 
2、浮动元素会停靠在父元素的左边或右边，或停靠在其他已浮动元素的边缘上(元素只能在当前所在行浮动) 
3、浮动元素依然位于父元素之内 
4、浮动元素处理的问题-解决多个块级元素在一行内显示的问题 
* 注意 
1、一行内，显示不下所有的已浮动元素时，最后一个将换行 
2、元素一旦浮动起来之后，那么宽度将变成自适应(宽度由内容决定) 
3、元素一旦浮动起来之后，那么就将变成块级元素,尤其对行内元素，影响最大 
块级元素：允许修改尺寸 
行内元素：不允许修改尺寸 
4、文本，行内元素，行内块元素时采用环绕的方式来排列的，是不会被浮动元素压在底下的，会巧妙的避开浮动元素
* 浮动 之后会有什么样的影响？ 
由于浮动元素会脱离文档流，所以导致不占据页面空间，所以会对父元素高度带来一定影响。如果一个元素中包含的元素全部是浮动元素，那么该元素高度将变成0（高度塌陷）
* 清除浮动的方法

1. 先找到浮动盒子的父元素，再在父元素中添加一个属性：overflow:hidden,就是清除这个父元素中的子元素浮动对页面的影响.  
但会将超出部分隐藏在某些时候我们想清除浮动并且保留超出部分时做不到

2. 给浮动元素内部添加浮动，或者绝对定位元素内部添加浮动，同overflow一样触发bfc属性，清除内部浮动。
3. 设置父元素display:table，display:table本身无法触发BFC，但是它会产生匿名框(anonymous boxes)，而匿名框中的display:table-cell可以触发BFC
>>表格模型中的元素，可能不会全部包含在除HTML之外的文档语言中。这时，那些“丢失”的元素会被模拟出来，从而使得表格模型能够正常工作。所有的表格元素将会自动在自身周围生成所需的匿名table对象，使其符合table/inline-table、table-row、table- cell的三层嵌套关系。

3. 在浮动的盒子之下再放一个空标签，在这个标签中使用clear:both，来清除浮动对页面的影响.
如果该标签放在父元素中则会将这个浮动盒子的父盒子高度重新撑开.                                                               如果该标签放在父元素外会将这个浮动盒子的影响清除，但是不会撑开该父元素
这种清除浮动的方式会增加页面的标签，不符合结构与表现分离的原则，不利于后期维护.

#### clear清除浮动的原因
clear的属性规定元素的那一侧不允许其他浮动元素，会在设置清除浮动的元素上外边距之上增加清除空间，而外边距本身并不改变
也就是说因为浮动而产生的空白空间，会被填充为实际存在的空间。clear:both 左右两侧均不允许浮动元素。
* clear:both清除浮动的顺序关系如下：
1设置元素A浮动，元素脱离文档流，不计算高度。父元素出现高度塌陷。
2浮动元素A产生空白空间。空间长宽等于元素A的长宽。后面元素会自动补空缺。
3给浮动元素之后的元素B设置clear:both，元素B将不去补空缺。
4元素B不仅不补空缺，还会把元素A因浮动而产生的空白空间填充为实际空间。
5实际空间被计算高度，父元素被撑开


4. 使用伪类清除浮动
* [伪类和伪元素详解](http://web.jobbole.com/86181/)
after伪选择符，就可以在父容器的尾部自动创建一个子元素
```
　.clearfix:after{

　　　　　　content:"";//设置内容为空

　　　　　　height:0;//高度为0

　　　　　　line-height:0;//行高为0

　　　　　　display:block;//将文本转为块级元素

　　　　　　visibility:hidden;//将元素隐藏

　　　　　　clear:both//清除浮动

　　　　　}

　　　　.clearfix{

　　　　　　zoom:1;//为了兼容IE

　　　　}   
```                                                                                                                    或者设置双伪元素
```
.clearfix:before,.clearfix:after {

                  content: "";

                  display: block;

                  clear: both;

            }

            .clearfix {

                  zoom: 1;

            }
```

```
.clearfix:before,.clearfix:after{
	      display:table;
	      content:"";
      }
.clearfix:after{
	      clear:both;
      }
.clearfix{
	      *zoom:1;//兼容ie
      }
```                
使用单伪元素更严谨。