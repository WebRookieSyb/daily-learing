#### 事件流
**事件流**描述的是从页面中接收事件的顺序,也可理解为事件在页面中传播的顺序
事件就是用户或浏览器自身执行的某种动作。诸如click(点击)、load(加载)、mouseover(鼠标悬停)。
事件对象，用于储存事件的状态。
事件源对象（事件处理程序），当前事件在操作的对象，如元素节点，文档对象，window对象，XMLHttpRequest对象等。
事件监听器，当一个事件源生成一个事件对象时，它会调用相应的回调函数进行操作。在IE中，事件对象恒为全局属性window.event的分身

IE提出的是“事件冒泡流”

Netscape提出的是“事件捕获流”

* 事件冒泡流：即事件最开始由最具体的元素（文档中嵌套层次最深的那个节点）接收，然后逐级向上传播至最不具体的那个节点（document）。
* 事件捕获流：与冒泡流截然相反，它的定义是最不具体的节点应该更早接收到事件，而最具体的节点最后接收到事件。

**一个完整的JS事件流是从window开始，最后回到window的一个过程，事件流被分为三个阶段捕获过程、目标过程、冒泡过程。（所以如果一个对象ji绑定冒泡又绑定捕获，先执行捕获）**

##### 事件处理程序
[dom事件处理程序](https://segmentfault.com/a/1190000006667581)
1. HTML事件处理程序----事件直接加在HTML结构里的---(不常使用)

缺点：HTML代码与js紧密的耦合在一起

2. DOM0级事件处理程序（w3c标准来说，并没有0级ｄｏｍ的标准。只不过，事实上的适用总会成慢慢成为约定成俗的规则。）---先将元素取出来，再对元素属性进行赋值进行事件处理

较传统的一个方式：把一个函数赋值给一个事件的处理程序属性

删除DOM0事件处理程序，只要将对应事件属性  置为null即可。

优点：简单   跨浏览器

缺点：DOM 0中的只能一个元素只能绑定一个事件，并且绑定的是最后绑定的那个事件,后面的会覆盖掉前面的内容一样(说明dom0不会阻止冒泡，但dom0不支持捕获)

3. DOM2级事件处理程序--元素.addEventListener()/元素.removeEventListener()

DOM2级事件定义了两个方法，用于处理指定和删除事件处理程序的操作：addEventListener();和removeEventListener();

都需要三个参数：要处理的事件名（事件不加on，比如之前的onclick，在这里只需要写click，再比如onmouseover，在这里只需要写mouseover）、作为事件处理程序的函数（不需要加括号）和布尔值（true表示在捕获阶段调用事件处理程序，false表示在冒泡阶段调用事件处理程序）

处理函数中的this依然指的是指当前dom元素。

)  通过addEventListener添加的事件处理程序，只能通过removeEventListener来删除，也就是说通过addEventListener添加的匿名函数将无法被删除。

4. IE事件处理程序--支持的浏览器（IE和OPERA），冒泡执行的，依旧是dom2

attachEvent():添加事件

detachEvent():删除事件

都需要两个参数:事件处理程序的名称（事件加on）和事件处理程序的函数（不需要加括号）

采用DOM0级处理方式，事件处理程序会在其所属元素的作用域内运行。使用attachEvent，事件处理程序会在全局作用域内运行，因此this等于window。

##### 事件绑定，事件监听，事件委托
* 事件绑定

要想让 JavaScript 对用户的操作作出响应，首先要对 DOM 元素绑定事件处理函数。所谓事件处理函数，就是处理用户操作的函数，不同的操作对应不同的名称。

1.在DOM元素中直接绑定；

2.在JavaScript代码中绑定；

3.绑定事件监听函数。

* 事件监听
用 addEventListener() 或 attachEvent() 来绑定事件监听函数


* 事件委托（事件代理）
事件冒泡和目标元素，把事件处理器添加到父元素，等待子元素事件冒泡，并且父元素能够通过target（IE为srcElement）判断是哪个子元素，从而做相应处理


1. 管理的函数变少了。不需要为每个元素都添加监听函数。对于同一个父节点下面类似的子元素，可以通过委托给父元素的监听函数来处理事件。

2. 动态的添加DOM元素无需重新绑定事件处理器，因为事件代理对不同子元素可采用不同处理方法。如果新增其他子元素（a,span,div等），直接修改事件代理的事件处理函数即可，不需要重新绑定处理器，不需要再次循环遍历

3. JavaScript和DOM节点之间的关联变少了，这样也就减少了因循环引用而带来的内存泄漏发生的概率。将多个事件处理器减少到一个，因为事件处理器要驻留内存，这样就提高JavaScript性能。事件委托可以显著的提高事件的处理速度，减少内存的占用

#### 事件对象event
**事件对象event**
事件在浏览器中是以对象的形式存在的，即event。触发一个事件，就会产生一个事件对象event，该对象包含着所有与事件有关的信息。包
* DOM0级和DOM2级事件处理程序都会把event作为参数传入。

**ie的事件对象**
通过DOM0级方法添加事件处理程序时，event对象作为window对象的一个属性存在。
* 通过attachEvent()添加的事件处理程序，event对象作为参数传入。

* IEChrome中事件对象是作为全局对象( window.event )存在的，Firefox中则是做为句柄( handler )的第一个参数(arguments[0])传入内的。

注意兼容var evt = window.event || e;

* ie下：obj.attachEvent(事件名称，事件函数)；  
1.没有事件捕获  
2.事件名称中没有on  
3.事件执行顺序 非标准->倒序  
4.this指向window  
 
* 2.标准下 document.addEventListener(事件名称，事件函数，是否捕获)   
1.有捕获  
2.事件名称中没有on  
3.事件执行是正序  
4.this指向该触发事件的对象  

[event事件对象](https://www.jianshu.com/p/c99905810bce)

####事件对象的属性
1. DOM中的事件对象

（1）type属性：用于获取事件类型 (event.type)

（2）target属性：用于获取事件目标 (event.target   /    event.target.nodeName)

（3）stopPropagation():用于阻止事件冒泡

（4）preventDefault():阻止事件的默认行为,移动端用的多

2. IE中的事件对象

（1）type属性：用于获取事件类型 (event.type)

（2）srcElement属性：用于获取事件的目标

（3）cancelBubble属性：用于阻止事件冒泡(设置为true表示阻止冒泡   设置false表示不阻止冒泡)

（4）returnValue属性：用于阻止事件的默认行为（设置为false表示阻止事件默认行为）

3. 不同的事件类型
鼠标事件：

鼠标事件都是在浏览器窗口中的特定位置上发生的。这个位置信息保存在事件的clientX和clientY属性中。所有浏览器都支持这两个属性，它们的值表示事件发生时鼠标指针在视口中的水平和垂直坐标。不包括页面滚动的距离。
    
onmousedown（用户按下任何鼠标按钮时触发）

onmousemove（当鼠标指针在元素内部移动时重复的触发）

onmouseup（当用户释放鼠标按钮时触发）



键盘事件：

keyDown（当用户按下键盘上的任意键时触发，而且如果按住不放的话，会重复触发此事件）

keyPress（当用户按下键盘上的字符键时触发，而且如果按住不放的话，会重复触发此事件）

keyUp（当用户释放键盘上的键时触发）

event对象的keyCode属性用于得到键盘对应键的键码值

